# TODO: Generate DBT's profiles.yml as an asset, with dynamic content based on the clients DB. This will allow for running models with the --profile flag and targetting the client's specific database

from typing import Dict, List
from os import environ
from pathlib import Path

import dagster as dg
from dagster import AssetExecutionContext
from dagster_dbt import (
    DagsterDbtTranslator,
    DagsterDbtTranslatorSettings,
    DbtProject,
    DbtCliResource,
    dbt_assets,
    get_asset_key_for_model
)
from dagster_dlt import DagsterDltResource, dlt_assets
import dlt
from dlt.sources.rest_api import (
    RESTAPIConfig,
    rest_api_resources,
)
import pandas as pd

from models.client import Client
from models.dlt_rest_config import (
    DltRestConfig,
    OktaUsers,
    OktaGroups,
    OktaApps,
    OktaDevices,
    OktaAccessPolicies,
    OktaMfaEnrollmentPolicies,
    OktaPasswordPolicies,
    OktaProfileEnrollmentPolicies,
    OktaSignOnPolicies,
    OktaLogEvents,
    )

DLT_SOURCES: DltRestConfig = [
    OktaUsers,
    OktaGroups,
    OktaApps,
    OktaDevices,
    OktaAccessPolicies,
    OktaMfaEnrollmentPolicies,
    OktaPasswordPolicies,
    OktaProfileEnrollmentPolicies,
    OktaSignOnPolicies,
    OktaLogEvents,
]

dbt_project = DbtProject(
    project_dir=Path(__file__).joinpath('..', '..', 'dbt_project').resolve()
)
dbt_project.prepare_if_dev()

CLIENTS_DB = [
    Client({
        'id': 'A0000001',
        'name': 'dev-44559887',
        'org_url': 'https://dev-44559887.okta.com',
        'api_token': '00C7g1V8AtbUNeLpnpVPEkhKuAXqbgHSZ6B9KmndFO'
        }),
    Client({
        'id': 'A0000002',
        'name': 'dev-14449001',
        'org_url': 'https://dev-14449001.okta.com',
        'api_token': '00pGgPKFqvwjLNuBYt5i5QatmmKaE3Onf11lmEp1m-'
        })
]


class ClientAwareDbtTranslator(DagsterDbtTranslator):
    def __init__(self, settings = None, client: Client = None):
        super().__init__(settings)
        self._client = client
        self.__dbt_source_to_asset_key_map = None

    @property
    def _dbt_source_to_asset_key_map(self):
        if not self.__dbt_source_to_asset_key_map:
            # figure out one of the asset keys that will be generated by each DLT resource
            # key the map by the config class name, which is also used for the SQL schema (and DBT provides that name in dbt_resource_props)
            map = {}
            for config_class in DLT_SOURCES:
                c = config_class(None, None)
                map[c.name] = (
                    f'dlt_{self._client.id}_{c.name}_{c.resource_postfix_for_dbt_model_linking}')
            self.__dbt_source_to_asset_key_map = map
            return map
        else:
            return self.__dbt_source_to_asset_key_map

    def get_asset_key(self, dbt_resource_props):
        resource_type = dbt_resource_props['resource_type']
        name = dbt_resource_props['name']
        schema = dbt_resource_props['schema']
        dlt_source_key = self._dbt_source_to_asset_key_map.get(schema)
        
        if resource_type == 'model':
            return dg.AssetKey(f'{self._client.id}_{name}')
        elif resource_type == 'source' and dlt_source_key:
            return dg.AssetKey(dlt_source_key)
        else:
            return super().get_asset_key(dbt_resource_props)

def add_data_maps(resources, config):
    for resource in resources: # add all the data maps for the given resource
        for map in config.data_maps:
            resource.add_map(
                lambda data: map(data)
            )
    return resources


def definitions_for_a_single_client(client: Client, dlt_resource: DagsterDltResource, dbt_resource: DbtCliResource):
    # TODO: name this better and sort out if you're keeping this hacky map thing
    dlt_assets_map = {}

    # Generate assets for all of the DLT sources. You can access them later for deps etc. via assets_map
    for config_class in DLT_SOURCES:

        @dlt.source(name=f'{client.id}_{config_class.name}')
        def dlt_source_func():
            config = config_class(client.org_url, client.api_token)
            resources = rest_api_resources(config.rest) # returns a variable number of resources depending on REST config
            resources = add_data_maps(resources, config)

            yield from resources

        @dlt_assets(
            dlt_source=dlt_source_func(),
            dlt_pipeline=dlt.pipeline(
                pipeline_name=f'{client.id}_{config_class.name}',
                destination=dlt.destinations.postgres(f'postgresql://postgres:mysecretpassword@localhost:5433/{client.id}'),
                dataset_name=config_class.name
            ),
            name=f'{client.id}_{config_class.name}'
        )
        def dlt_assets_func(context: AssetExecutionContext, dlt: DagsterDltResource):
            yield from dlt.run(context=context)
        

        dlt_assets_map[config_class.name] = dlt_assets_func

    @dbt_assets(
        manifest=dbt_project.manifest_path,
        dagster_dbt_translator=ClientAwareDbtTranslator(
            settings=DagsterDbtTranslatorSettings(enable_duplicate_source_asset_keys=True),
            client=client),
        name=f'{client.id}_dbt',
    )
    def dbt_assets_func(context: dg.AssetExecutionContext, dbt: DbtCliResource):
        yield from dbt.cli(['run', '--profile', client.id], context=context).stream()

    dlt_assets_map['dbt_assets'] = dbt_assets_func

    @dg.asset(deps=[
        get_asset_key_for_model([dbt_assets_func], f'stg_new_user_events')
        ],
        name=f'{client.id}-new-users')
    def new_users():
        pass

    dlt_assets_map['new_users'] = new_users

    return dg.Definitions(
            assets=list(dlt_assets_map.values()),
            resources={
                'dlt': dlt_resource,
                'dbt': dbt_resource
            }
        )

dlt_resource = DagsterDltResource()
dbt_resource = DbtCliResource(
    project_dir=dbt_project
)

definitions_for_all_clients = []
for client in CLIENTS_DB:
    definitions_for_all_clients.append(definitions_for_a_single_client(client, dlt_resource, dbt_resource))

defs = dg.Definitions.merge(*definitions_for_all_clients)
